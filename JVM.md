# JVM

## 运行时数据区域

- 方法区 Method Area
- 虚拟机栈 VM Stack
- 本地方法栈 Native Method Stack
- 堆 Heap
- 程序计数器 Program Counter Register

### 程序计数器

可以看作当前线程执行的字节码的行号指示器。

在虚拟机概念模式里（仅概念模型，各种虚拟机可能会通过一些更高效的方式实现），字节码解释器工作时会改变计数器的值来选取下一条执行的字节码指令，分支，循环，异常，线程恢复等基础功能都需要依赖这个计数器来完成。

### Java虚拟机栈

Java虚拟机栈和程序计数器一样也是线程私有的。

它的生命周期和线程相同。

虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表，操作栈，动态链接，方法出口等信息。

#### 局部变量

存放编译可知的各种基本数据类型：boolean，byte,char,short,int,float,long,double,对象引用（可能是原始地址，也可能是对象的句柄或相关的位置）和returnAddress（下一条字节码指令地址）类型。

其中long和double类型会占用两个局部变量空间（slot），其余只占用一个。局部变量所需的内存空间会在编译期间完成分配，运行期间不会改变局部变量表的大小。

#### 异常

StackOverflowError

线程请求的最大栈深度大于虚拟机允许的最大深度，会抛出StackOverflowError异常。

OutofMemoryError

如果虚拟机栈可以动态扩展，当扩展无法申请到足够的内存则会抛出OutOfMemoryError异常。

### 本地方法栈

与虚拟机栈类似，只不过虚拟机栈为虚拟机执行Java方法（字节码）服务，而本地方法栈则是为虚拟机使用的Native方法服务。本地方法栈可以自由实现，有的甚至和虚拟机栈合二为一了。

### Java堆

Java堆是Java虚拟机所管理的内存中最大的一块。Java堆是所有线程共享的一块内存区域，在虚拟机启动时创建。存放的是对象实例。

Java堆是垃圾收集器管理的主要区域。因此很多时候也被称作CG堆。

如果堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出`OutOfMemoryError`异常。

### 方法区

方法区也是线程共享的内存区域，用于存储被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。

### 运行时常量池

是方法区的一部分。Class文件除了有类的版本，字段，方法，接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分类容将在类加载后存放到方法区的运行时常量池中。

### 直接内存

直接内存并不是虚拟机运行时的一部分，也不是Java虚拟机规范中定义的内存区域。但这部分频繁使用，也可能产生`OutOfMemoryError`异常

## 垃圾收集器与内存分配策略

### GC需要完成三件事

- 哪些内存需要被回收
- 什么时候回收
- 如何回收

程序计数器，虚拟机栈，本地方法栈和线程生命周期一致，栈中的栈帧随方法的进入和退出有条不紊的执行出栈和入栈操作。每个栈帧的内存进本在类结构确定下来就已知。这部分区域不需要过多考虑回收问题，它们会随方法结束或线程结束，内存自然被回收。

而Java堆和方法区则不一样，一个接口的多个实现需要的内存可能不一样，一个方法的多个分支需要的内存可能也不一样，我们只有在程序处于运行期间才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，也是我们关注的。

### 对象已死？

GC对堆回收前会判断对象是否还“存活”即可能还会被使用的对象。

### 引用计数算法

给对象中添加一个引用计数器，每当有地方引用，计数器加一，引用失效减一。任何时刻计数器为0则表示不可能再被使用。

不能解决循环引用的问题。

### 根搜索算法

基本思路就是通过一系列名为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用相连，则证明此对象不可用。

GC Roots包括如下几种：

- 虚拟机栈中的引用对象。
- 方法区中的类静态属性引用的对象
- 方法区中的常量引用对象
- 本地方法栈中JNI（Native方法）的引用对象

### 引用

- 强引用 (Strong Reference)
- 软引用(Soft Reference)
- 弱引用(Weak Reference)
- 虚引用(Phantom Reference)

#### 强引用

指在程序代码普遍存在的，类似`Object obj = new Object()`这类引用，只要强引用还存在，GC永远不会回收掉引用的对象

#### 软引用

描述一些还拥有，但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中，并进行第二次回收，如果回收还没有足够的内存则会抛出内存溢出异常。

#### 弱引用

非必须的对象，但比软引用更弱，当GC工作时，不管内存是否足够都会回收。

#### 虚引用

称为幽灵引用，最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生成时间构成影响，也无法通过虚引用获取一个对象实例。设置虚引用的作用就是在GC回收时收到一个系统通知。

### 生存还是死亡？

对于根搜索算法不可达对象回收时，会进行至少进行两次标记过程。

如果对象进行根搜索后发现没在GC Roots链上，会进行第一次标记并进行一次筛选，筛选条件是此对象是否有必要执行`finalize()`方法，当对象没有覆盖`finalize()`方法，或`finalize()`方法已经被虚拟机调用过，虚拟机将这两种情况视为“没有必要执行”。

如果对象被判断为有必要执行`finalize()`方法，那么这个对象将会被放置在一个名为`F-Queue`队列中，并在稍后由一条由虚拟机自动创建的，优先级低的`Finalizer`线程去执行，但并不承诺会等待它运行完毕。原因是如果对象在`finalize()`方法中执行缓慢或发生死循环，会导致`F-Queue`队列的其他对象处于等待状态，导致回收系统崩溃。

`finalize()`方法是对象不被回收的最后一次机会，稍后GC将对`F-Queue`进行二次小规模标记。如果对象想要不被回收，则必须与GC Roots建立联系。

### 回收方法区

在方法区进行垃圾回收，效率远低于常规应用进行一次垃圾收集。

常规应用进行一次垃圾回收一般可以收集70%~95%的空间。

永久代的垃圾回收主要集中两个部分：

- 废弃常量
- 无用的类

#### 判断一个类是否有效

判断一个类是否有效必须同时满足如下3个条件

- 该类所有的实例已经被回收。即堆中没有该类的实例
- 该类的ClassLoader已经被回收
- 该类对应的java.long.Class对象没有任何地方被引用，无法在任何地方通过反射访问。

### 垃圾回收算法

- 标记-清除算法
- 复制算法

#### 标记-清除算法

分为`标记`和`清除`两个阶段。标记完成后统一回收所有被标记的对象。标记-清除算法是最基础的算法，其他收集算法都是基于这个思路对其的补充。

##### 主要缺点

- 效率问题

  标记和清除效率都不高

- 空间问题

  清除后会产生大量不连续的内存，空间碎片太多可能导致，程序在后续需要分配较大对象时，无法得到足够的内存而不得不再次触发垃圾收集。

#### 复制算法

为了解决效率问题，它将可用内存按容量划分为大小相等的两块，每次只是用其中一块，当这块用完了，就将存活的对象复制到另一块上，再把使用过的内存清除掉。这样每次都是对其中一块进行回收，也不用考虑内存碎片等复杂情况。这样的代价是内存缩小原来的一半。

现在商业虚拟机都采用这种收集算法回收新生代，但不需要按照1：1的比例来划分，而是分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和一块Survivor空间，最后清理Eden空间和其中一块Survivor空间。HotSpot虚拟机默认Eden和Survivor比例为8：1

#### 标记-整理算法

复制收集算法在对象存活率较多的复制操作，效率会变低。更关键的是，如果不想浪费50%的空间，就需要额外的分配担保，以应对使用内存中所有对象100%存活的极端情况。

所以老年代一般不能直接用这种算法。

标记-整理算法的标记过程和标记-清除一样，但后续步骤不是直接对对象进行回收，而是让所有存活的对象向一端移动，然后直接清理掉边界之外的内存。

#### 分代收集算法

当前商业虚拟机的收集都采用“分代收集”算法，这种算法并没有什么新思想，只是根据对象的存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代。这样就可以根据各个年代的特点采用最合适的收集算法。

在新生代中，每次来及收集会有大量对象死去，少量存活，采用复制算法。

而老年代中因为存活率高，没有额外的空间进行担保，就必须使用标记-清除算法或标记-整理算法。

## 垃圾回收器

### 内存分配与回收策略

#### 对象优先在Eden分配

大多数情况下，对象在新生代Eden区中分配，当Eden空间不足时，虚拟机会发起一次Minor GC

#### Minor GC 和Full GC区别

新生代GC(Minor GC) 指发生在新生代垃圾收集动作，非常频繁且回收速度较快。

老年代GC(Major GC / Full GC) 指发生在老年代的GC，经常会伴随一次Minor GC,但不是绝对的，速度一般会被Minor GC慢10倍以上。

#### 大对象直接进入老年代

所谓大对象指，需要大量连续内存空间的Java对象。

#### 长期存活的对象进入老年代

虚拟机给每个对象定义了一个对象年龄计数器，如果对象在Eden初始并经过第一次Minor GC并且能被Survivor容纳，会移到Survicor空间，并设置年龄为1，经历多次回收之后，年龄到达一定程度（MaxtenuingThreshold默认15）会被移到老年代。

#### 动态对象年龄判断

为了更好的适应不同程序的内存状况，虚拟机并不总是要求对象年龄必须达到MaxTenuringThreshold才移入老年代。如果在Survivor空间中相同年龄所有对象大小总和大于Survivor空间的一半，年龄大于或等于改年龄的对象可以直接进入老年代。

#### 空间分配担保

在发生Minor GC时，虚拟机会检测每次移入老年代的平均大小是否大于老年代的剩余空间大小，如果大于则进行一次Full GC，如果小于，则查看HandlePromotionFailure设置是否允许担保失败，如果不允许则也会执行一次Full GC。

### Class类文件的结构

Class文件是一组以八位字节为基础单位的二进制流，各个数据项严格按照顺序紧凑排列在Class文件中，中间没有添加任何分隔符。这使得真个Class文件中存储的内容几乎全部都是程序运行的必要数据，没有空隙存在，当遇到需要8位字节以上的数据项时，则会按照高位在前的方式分割成若干个8位字节。

Class文件格式采用一种类似C语言结构结构体的伪结构来存储。这种结构只有两种数据类型：无符号数和表。

无符号数表示基本数据类型。分别以u1,u2,u4,u8表示，1个字节，2个字节。。。可以用来描述数字，索引引用，数量值，或按UTF-8编码构成的字符串。

表是由多个无符号或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以`_info`结尾。