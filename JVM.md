# JVM

## 运行时数据区域

- 方法区 Method Area
- 虚拟机栈 VM Stack
- 本地方法栈 Native Method Stack
- 堆 Heap
- 程序计数器 Program Counter Register

### 程序计数器

可以看作当前线程执行的字节码的行号指示器。

在虚拟机概念模式里（仅概念模型，各种虚拟机可能会通过一些更高效的方式实现），字节码解释器工作时会改变计数器的值来选取下一条执行的字节码指令，分支，循环，异常，线程恢复等基础功能都需要依赖这个计数器来完成。

### Java虚拟机栈

Java虚拟机栈和程序计数器一样也是线程私有的。

它的生命周期和线程相同。

虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表，操作栈，动态链接，方法出口等信息。

#### 局部变量

存放编译可知的各种基本数据类型：boolean，byte,char,short,int,float,long,double,对象引用（可能是原始地址，也可能是对象的句柄或相关的位置）和returnAddress（下一条字节码指令地址）类型。

其中long和double类型会占用两个局部变量空间（slot），其余只占用一个。局部变量所需的内存空间会在编译期间完成分配，运行期间不会改变局部变量表的大小。

#### 异常

StackOverflowError

线程请求的最大栈深度大于虚拟机允许的最大深度，会抛出StackOverflowError异常。

OutofMemoryError

如果虚拟机栈可以动态扩展，当扩展无法申请到足够的内存则会抛出OutOfMemoryError异常。

### 本地方法栈

与虚拟机栈类似，只不过虚拟机栈为虚拟机执行Java方法（字节码）服务，而本地方法栈则是为虚拟机使用的Native方法服务。本地方法栈可以自由实现，有的甚至和虚拟机栈合二为一了。

### Java堆

Java堆是Java虚拟机所管理的内存中最大的一块。Java堆是所有线程共享的一块内存区域，在虚拟机启动时创建。存放的是对象实例。

Java堆是垃圾收集器管理的主要区域。因此很多时候也被称作CG堆。

如果堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出`OutOfMemoryError`异常。

### 方法区

方法区也是线程共享的内存区域，用于存储被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。

### 运行时常量池

是方法区的一部分。Class文件除了有类的版本，字段，方法，接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分类容将在类加载后存放到方法区的运行时常量池中。

### 直接内存

直接内存并不是虚拟机运行时的一部分，也不是Java虚拟机规范中定义的内存区域。但这部分频繁使用，也可能产生`OutOfMemoryError`异常

### 根搜索算法

基本思路就是通过一系列名为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用相连，则证明此对象不可用。

GC Roots包括如下几种：

- 虚拟机栈中的引用对象。
- 方法区中的类静态属性引用的对象
- 方法区中的常量引用对象
- 本地方法栈中JNI（Native方法）的引用对象

### 引用

- 强引用 (Strong Reference)
- 软引用(Soft Reference)
- 弱引用(Weak Reference)
- 虚引用(Phantom Reference)

#### 强引用

指在程序代码普遍存在的，类似`Object obj = new Object()`这类引用，只要强引用还存在，GC永远不会回收掉引用的对象

#### 软引用

描述一些还拥有，但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中，并进行第二次回收，如果回收还没有足够的内存则会抛出内存溢出异常。

#### 弱引用

非必须的对象，但比软引用更弱，当GC工作时，不管内存是否足够都会回收。

#### 虚引用

称为幽灵引用，最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生成时间构成影响，也无法通过虚引用获取一个对象实例。设置虚引用的作用就是在GC回收时收到一个系统通知。

### 生存还是死亡？

对于跟搜索算法不可达对象回收时，会进行至少进行两次标记过程。

如果对象进行根搜索后发现没在GC Roots链上，会进行第一次标记并进行一次筛选，筛选条件是此对象是否有必要执行`finalize()`方法，当对象没有覆盖`finalize()`方法，或`finalize()`方法已经被虚拟机调用过，虚拟机将这两种情况视为“没有必要执行”。

如果对象被判断为有必要执行`finalize()`方法，那么这个对象将会被放置在一个名为`F-Queue`队列中，并在稍后由一条由虚拟机自动创建的，优先级低的`Finalizer`线程去执行，但并不承诺会等待它运行完毕。原因是如果对象在`finalize()`方法中执行缓慢或发生死循环，会导致`F-Queue`队列的其他对象处于等待状态，导致回收系统崩溃。

`finalize()`方法是对象不被回收的最后一次机会，稍后GC将对`F-Queue`进行二次小规模标记。如果对象想要不被回收，则必须与GC Roots建立联系。