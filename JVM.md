# JVM

## 运行时数据区域

- 方法区 Method Area
- 虚拟机栈 VM Stack
- 本地方法栈 Native Method Stack
- 堆 Heap
- 程序计数器 Program Counter Register

### 程序计数器

可以看作当前线程执行的字节码的行号指示器。

在虚拟机概念模式里（仅概念模型，各种虚拟机可能会通过一些更高效的方式实现），字节码解释器工作时会改变计数器的值来选取下一条执行的字节码指令，分支，循环，异常，线程恢复等基础功能都需要依赖这个计数器来完成。

### Java虚拟机栈

Java虚拟机栈和程序计数器一样也是线程私有的。

它的生命周期和线程相同。

虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表，操作栈，动态链接，方法出口等信息。

#### 局部变量

存放编译可知的各种基本数据类型：boolean，byte,char,short,int,float,long,double,对象引用（可能是原始地址，也可能是对象的句柄或相关的位置）和returnAddress（下一条字节码指令地址）类型。

其中long和double类型会占用两个局部变量空间（slot），其余只占用一个。局部变量所需的内存空间会在编译期间完成分配，运行期间不会改变局部变量表的大小。

#### 异常

StackOverflowError

线程请求的最大栈深度大于虚拟机允许的最大深度，会抛出StackOverflowError异常。

OutofMemoryError

如果虚拟机栈可以动态扩展，当扩展无法申请到足够的内存则会抛出OutOfMemoryError异常。

### 本地方法栈

与虚拟机栈类似，只不过虚拟机栈为虚拟机执行Java方法（字节码）服务，而本地方法栈则是为虚拟机使用的Native方法服务。本地方法栈可以自由实现，有的甚至和虚拟机栈合二为一了。

### Java堆

Java堆是Java虚拟机所管理的内存中最大的一块。Java堆是所有线程共享的一块内存区域，在虚拟机启动时创建。存放的是对象实例。

Java堆是垃圾收集器管理的主要区域。因此很多时候也被乘坐CG堆。

如果堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出`OutOfMemoryError`异常。

### 方法区

方法区也是线程共享的内存区域，用于存储被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。

### 运行时常量池

是方法区的一部分。Class文件除了有类的版本，字段，方法，接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分类容将在类加载后存放到方法区的运行时常量池中。

### 直接内存

直接内存并不是虚拟机运行时的一部分，也不是Java虚拟机规范中定义的内存区域。但这部分频繁使用，也可能产生`OutOfMemoryError`异常